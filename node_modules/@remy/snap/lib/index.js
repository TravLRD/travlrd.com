'use strict';

var _promise = require('babel-runtime/core-js/promise');

var _promise2 = _interopRequireDefault(_promise);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var fs = require('fs');
var parse = require('url').parse;
var path = require('path');
var rimraf = require('rimraf');
var mkdirp = require('mkdirp');
var Crawler = require('simplecrawler');
var root = process.cwd();
var noop = function noop() {};

module.exports = function (args, settings) {
  var url = args._[0];

  if (url && !url.startsWith('http')) {
    // assume http
    url = 'http://' + url;
  }

  if (!url) {
    throw new Error('snap <url> [--output <dir>]');
  }

  var output = args.output || parse(url).hostname;

  return new _promise2.default(function (resolve, reject) {
    rimraf(path.join(root, output), function (error) {
      if (error) {
        return reject(error);
      }

      resolve(crawl(url, output));
    });
  });
};

function crawl(url, output) {
  return new _promise2.default(function (resolve, reject) {
    console.error('fetching %s', url);

    var crawler = new Crawler(url);

    if (url.includes('localhost')) {
      crawler.interval = 0;
      crawler.maxConcurrency = 100;
      crawler.respectRobotsTxt = false;
      crawler.stripQuerystring = true;
    }

    // crawler.addDownloadCondition((queueItem, response, callback) => {
    //   callback(null,
    //     queueItem.stateData.contentType.startsWith('text/html')
    //   );
    // });

    crawler.on('fetchclienterror', function (queueItem, error) {
      console.error("Client error, could not fetch %s", queueItem.url);
      throw error;
    });

    crawler.on('fetchcomplete', function (queueItem, responseBuffer, response) {

      // Parse url
      var parsed = parse(queueItem.url);

      // Rename / to index.html
      if (parsed.pathname === '/') {
        parsed.pathname = '/index.html';

        // this ensures that we have .html suffix hidden and directories instead
      } else if (response.headers['content-type'].includes('text/html')) {
        if (parsed.pathname.match(/.html?$/)) {
          // Do nothing as the .html file is directly pointed to.
        } else if (parsed.pathname.match(/\/$/)) {
          // Trailing slash so the link points to a directory.
          parsed.pathname += 'index.html';
        } else {
          // A pretty URL
          parsed.pathname += '/index.html';
        }
      }

      // Where to save downloaded data
      var outputDirectory = path.join(root, output);

      // Get directory name in order to create any nested dirs
      var dirname = outputDirectory + parsed.pathname.replace(/\/[^\/]+$/, '');

      // Path to save file
      var filepath = outputDirectory + parsed.pathname;

      // Check if DIR exists
      fs.exists(dirname, function (exists) {
        // If DIR exists, write file
        if (exists) {
          fs.writeFile(filepath, responseBuffer, noop);
        } else {
          // Else, recursively create dir using node-fs, then write file
          mkdirp(dirname, function () {
            fs.writeFile(filepath, responseBuffer, noop);
          });
        }
      });

      console.error('%s (%s %d bytes)', queueItem.url, response.headers['content-type'], responseBuffer.length);
    });

    crawler.start();
  });
}